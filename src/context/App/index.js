// @ts-check

/**
 * This file is part of the BlockLotto core functionality.
 * 
 * DO NOT EDIT THIS FILE DIRECTLY.
 * Any changes to this file may cause unexpected behavior.
 * Please consult the project maintainers before making modifications.
 */
import React, { createContext, useContext, useEffect, useState } from 'react';
import { useCashTab } from '../CashTab';
import { Modal } from 'antd';
import { bcrypto, KeyRing, TX, Coin, Script } from '@hansekontor/checkout-components';
const { SHA256 } = bcrypto;
import { useHistory, useLocation } from 'react-router-dom';
import useBCH from '../../hooks/useBCH';
import { U64 } from 'n64';

// core modules
import { schrodingerOutscript, readTicketAuthCode, calculatePayout } from '../../utils/ticket';
import { useNotifications } from '../Notifications';
import useScript from '../../hooks/useScript';
import TXUtil from '../../utils/txutil';
import playerWinningsTier from '../../constants/winningTiers';
import sleep from '../../utils/sleep';
import { getWalletState } from '../../utils/cashMethods';
import { getFormattedTicketData } from '../../utils/ticket';

export const AppContext = createContext/** @type {import('./types').AppContextValue} */({});

export const AppWrapper = ({ Loading, children, user, setUser }) => {
    const history = useHistory();
    const location = useLocation();
    const { wallet, balance, addMinedTicketToStorage, addRedeemTxToStorage, createWallet, validateMnemonic, forceWalletUpdate } = useCashTab();
    const { getTxBcash, broadcastTx } = useBCH();
    const notify = useNotifications();
    const walletState = getWalletState(wallet);
    const { tickets } = walletState;

    /**
     * @typedef {number[]} PlayerNumbers
     * An array of 0 to 4 numbers, where each number is between 0 and 127.
     */
    /** @type {[PlayerNumbers, React.Dispatch<React.SetStateAction<PlayerNumbers>>]} */
    const [playerNumbers, setPlayerNumbers] = useState(
        /** @type {PlayerNumbers} */([])
    );

    /** @type {[string, (value: string) => void]} */
    const [loadingStatus, setLoadingStatus] = useState("");

    /** @type {[boolean, (value: boolean) => void]} */
    const [loader, setLoader] = useState(true);

    /** @type {Array} */
    const [unredeemedTickets, setUnredeemedTickets] = useState([]);

    /** @type {Array} */
    const [redeemableTickets, setRedeemabletickets] = useState([]);

    /** @type {Array} */
    const [ticketsToRedeem, setTicketsToRedeem] = useState([]);

    /** @type {Array} */
    const [gameTickets, setGameTickets] = useState([]);

    /** @type {[number, (value: number) => void]} */
    const [ticketQuantity, setTicketQuantity] = useState(1);

    const [protection, setProtection] = useState(false);
    const [walletUpdateAvailable, setWalletUpdateAvailable] = useState(false);
    const [etokenTimeout, setEtokenTimeout] = useState(false);  

    const [affiliate, setAffiliate] = useState({});
    const [externalAid, setExternalAid] = useState(""); 

    const [isFirstTicket, setIsFirstTicket] = useState(true);
    
    const [email, setEmail] = useState(false);

    useEffect(() => {
        const unlisten = history.listen(() => {
            setLoadingStatus("");
        });
        return () => unlisten();
    }, [history]);

    // get own affiliate data
    useEffect(() => {
        const getAffiliate = () => {
            // get aid
            const aidBuf = Buffer.from(wallet.Path1899.publicKey, 'hex');
            const aid = aidBuf.toString('base64');
            
            const query = new URLSearchParams({
                aid
            });
            const url = `${window.location.protocol}//${window.location.host}/#/?${query}`;

            console.log("setting affiliate", aid);
            setAffiliate({
                aid,
                url
            });
        }

        getAffiliate();
    }, [wallet]);

    // get external aid from url
    useEffect(() => {
        const getAidFromQuery = () => {
            const aidBase64FromQuery = new URLSearchParams(location.search).get('aid');

            if (aidBase64FromQuery) {
                try {
                    const aidBuf = Buffer.from(aidBase64FromQuery, 'base64');
                    const aidKeyring = new KeyRing(aidBuf);
                    const aidPubkey = aidKeyring.getPublicKey('hex');
                    console.log("aidPubkey", aidPubkey);
                    setExternalAid(aidPubkey);
                } catch(err) {
                    console.error('Invalid Affiliate ID:', err);
                }
            }
        }

        getAidFromQuery();

    }, []);

    // update new tickets
    useEffect(() => {
        const newUnredeemedTickets = tickets.filter(ticket => !ticket.redeemTx);
        setUnredeemedTickets(newUnredeemedTickets);

        const newRedeemableTickets = newUnredeemedTickets.filter(ticket => ticket.issueTx?.height > 0);
        setRedeemabletickets(newRedeemableTickets);
    }, [tickets]);

    // update wallet availability upon new tickets
    useEffect(() => {
        if (unredeemedTickets.length > 0) {
            if (!walletUpdateAvailable)
                setWalletUpdateAvailable(true);
        } else if (walletUpdateAvailable) {
            setWalletUpdateAvailable(false);
        }
    }, [unredeemedTickets]);

    // set isFirstTicket false if 2nd ticket has been bought
    useEffect(() => {
        if (tickets.length > 0) {
            if (isFirstTicket) {
                setIsFirstTicket(false);
            }
        } else {
            if (!isFirstTicket) {
                setIsFirstTicket(true);
            }
        }
    }, [tickets]);

    // update email state from user
    useEffect(() => {
        console.log("useEffect email")
        const updateEmail = user.email && !email;
        console.log("updateEmail", updateEmail);
        console.log("user.email", user.email);
        console.log("email", email);
        if (updateEmail) {
            setEmail(user.email);
        }
    }, [user])    

    // turn off etokenTimeout after 30 seconds
    useEffect(() => {
        async function endEtokenTimeout() {
            const timeout = 30 * 1000;
            await sleep(timeout);
            setEtokenTimeout(false);
        }

        if (etokenTimeout)
            endEtokenTimeout();
    }, [etokenTimeout])

    const getMinedTicket = async (hash) => {
        const ticketRes = await fetch(`https://lsbx.nmrai.com/v1/ticket/${hash}`, {
            method: "GET",
            headers: new Headers({
                'Accept': "application/json",
                'Content-Type': "application/json"
            }),
            mode: "cors",
            signal: AbortSignal.timeout(20000),
        });
        if (ticketRes.status !== 200)
            notify({ type: "error", message: "API Error"});
        const minedTicket = await ticketRes.json();
        return minedTicket;
    }

    const redeemTicket = async (ticket) => {
        let minedTicket = ticket.parsed?.minedTicket;

        if (!minedTicket?.lottoSignature) {
            const issueHash = ticket.issueTx.hash;
            minedTicket = await getMinedTicket(issueHash);

            if (!minedTicket.lottoSignature) {
                notify({type: "error", message: "Ticket not redeemable"});
                return false;
            }

            await addMinedTicketToStorage(issueHash, minedTicket);
        } 

        const ttx = TX.fromRaw(minedTicket.hex, 'hex');

        // Stamp comes from Authorizer address 
        const authPubkey = ttx.inputs[0].script.getData(1);

        // Shrodinger
        const outScript = schrodingerOutscript(authPubkey);

        // Build payout tx
        const ptx = new TXUtil();

        // Add ticket input
        const pcoin = Coin.fromTX(ttx, 1, -1);
        ptx.addCoin(pcoin);

        // Add outputs from ttx OP_RETURN
        const ttxOpreturnAuthBuf = ttx.outputs[0].script.code[1].data;
        const parsedticketAuthCode = readTicketAuthCode(ttxOpreturnAuthBuf);

        // We also need the block header and block auth sig
        console.log("redeemTicket() minedTicket.lottoSignature", minedTicket.lottoSignature);
        const blockAuthSig = Buffer.from(minedTicket.lottoSignature, 'hex');

        const maxPayout = parsedticketAuthCode.txOutputs[0].script.toRaw().slice(-8)
        const { actualPayoutBE, tier, opponentNumbers, resultingNumbers } = calculatePayout(
            ttx.hash(),
            Buffer.from(minedTicket.block, 'hex').reverse(),
            parsedticketAuthCode.minterNumbers,
            maxPayout,
            playerWinningsTier.map(obj => obj.threshold)
        );

        console.log("actualPayout", actualPayoutBE);
        console.log('actualPayoutNum', U64.fromBE(actualPayoutBE).toNumber())

        // Set the actual payout
        parsedticketAuthCode.txOutputs[0].script = Script.fromRaw(Buffer.concat([
            parsedticketAuthCode.txOutputs[0].script.toRaw().slice(0, -8),
            actualPayoutBE
        ]))

        ptx.outputs = parsedticketAuthCode.txOutputs

        // Do signature
        const sigHashType = Script.hashType.ALL | Script.hashType.SIGHASH_FORKID;
        const flags = Script.flags.STANDARD_VERIFY_FLAGS;
        const playerKeyring = KeyRing.fromSecret(wallet.Path1899.fundingWif);
        ptx.template(playerKeyring); // prepares the template
        const sig = ptx.signature(0, outScript, pcoin.value, playerKeyring.privateKey, sigHashType, flags);
        const preimage = ptx.getPreimage(0, outScript, pcoin.value, sigHashType, false);
        // console.log('preimage length: ', Buffer.from(preimage.toString('hex'), 'hex').length)

        const items = [
            sig,
            playerKeyring.getPublicKey(),
            blockAuthSig, // block auth signature
            Buffer.from(preimage.toString('hex'), 'hex'),
            Buffer.from(minedTicket.header, 'hex'),
            ttx.toRaw(),
            outScript.toRaw()
        ];
        ptx.inputs[0].script.fromItems(items);
        // console.log("sigScript length", ptx.inputs[0].script.toRaw().length)

        console.log(ptx)
        const ptxHex = ptx.toRaw().toString('hex')
        // console.log(ptxHex)

        console.log('verify', ptx.verify())
        try {
            const ptxBroadcast = await broadcastTx(ptxHex)
            console.log('ptxBroadcast', ptxBroadcast)

            if (ptxBroadcast.success) {
                console.log('ptx id', ptx.txid())

                const redeemData = {
                    payoutAmountNum: U64.fromBE(actualPayoutBE).toNumber(),
                    tier,
                    opponentNumbers,
                    resultingNumbers
                }
                await addRedeemTxToStorage(ptx, redeemData);

                const redeemHash = ptx.txid();

                // remove redeemed ticket from ticketsToRedeem
                const outstandingTickets = ticketsToRedeem;
                outstandingTickets.shift();
                setTicketsToRedeem(outstandingTickets);

                return redeemHash;
            } else {
                notify({type: "error", message: "Broadcasting Unsuccesful"});
                return;
            }
        } catch (err) {
            console.error(err);
            notify({type: "error", message: "Broadcasting Error"});
            return;
        }
    }

    // checks if ticket can be redeemed
    const checkTicketRedeemability = async (ticket, polling, onError) => {
        try {
            const isRedeemedTicket = ticket.redeemTx?.hash ? true : false;
            if (isRedeemedTicket) {
                throw new Error ("Ticket has already been redeemed");
            }

            const issueTxFromNode = await getTxBcash(ticket.issueTx.hash);
            let isMined = issueTxFromNode?.height > -1;
            const hasLottoSig = ticket.parsed?.minedTicket?.lottoSignature;

            if (isMined || hasLottoSig) {
                console.log("isMined", isMined);
                return true;
            } else if (polling) {
                console.log("CHECKREDEEMABILITY start polling");
                // poll indexer every 2 min
                const timeBetweenPolling = 2 * 60 * 1000;

                while (!isMined) {
                    console.log("Polling: started waiting period");
                    await sleep(timeBetweenPolling);
                    const issueTxFromNode = await getTxBcash(ticket.issueTx.hash);
                    console.log("issueTxFromNode", issueTxFromNode);
                    if (!issueTxFromNode) {
                        notify({ error: "error", message: "Transaction does not exist"});
                        return false;
                    }
                    isMined = issueTxFromNode.height > -1;
                    console.log("isMined", isMined);
                    if (!isMined) {
                        notify({ message: "Please wait...", type: "info" });
                    } else {
                        notify({ message: "You can redeem your ticket now!", type: "success" });
                        return true;
                    }                    
                }
            } else {
                return false;
            }
        } catch(err) {
            return onError(err);
        }
    }

    const changeEmail = async (emailInput) => {
        const isValidEmail = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/.test(emailInput);
        if (!isValidEmail) {
            throw new Error("Invalid Email");
        }

        const isOldEmail = emailInput === email;
        if (isOldEmail) {
            throw new Error("Old Email Address");
        }

        const keyring = KeyRing.fromSecret(wallet.Path1899.fundingWif);
		const msg = Buffer.from(emailInput, 'utf-8');
		const sig = keyring.sign(SHA256.digest(msg));

		const json = {
			email: emailInput, 
			pubkey: wallet.Path1899.publicKey,
			signature: sig.toString('hex'),			
		};
		console.log("json", json);
		const userRes = await fetch("https://lsbx.nmrai.com/v1/user", {
			method: "POST", 
			mode: "cors",
			headers: new Headers({
				"Content-Type": "application/json"
			}),
			signal: AbortSignal.timeout(20000),
			body: JSON.stringify(json)
		});
		console.log("userRes", userRes);
		// forward based on response
		const userResJson = await userRes.json();
		console.log("userResJson", userResJson);
		if (userRes.status === 200) {
            console.log("blocklotto call setEmail() with", emailInput)
            setEmail(emailInput);
            notify({
                type: "success",
                message: "Email has been changed"
            });
        } else {
            throw new Error("Email API Error");
		}
    }
    
    const importWallet = async (mnemonic) => {
        setLoadingStatus("IMPORT WALLET");
        await createWallet(mnemonic);
        setWalletUpdateAvailable(false);
        setLoadingStatus(false);
    }

    const updateWallet = async () => {
        if (walletUpdateAvailable) {
            setLoadingStatus("LOADING WALLET");
            await forceWalletUpdate();
            await sleep(3000);
            setWalletUpdateAvailable(false);
            setLoadingStatus(false);            
        } else {
            notify({ type: "error", message: "Wallet Update unavailable"});
        }
    }

    return (
        <AppContext.Provider value={{
            protection,
            user,
            email,
            wallet,
            unredeemedTickets,
            redeemableTickets,
            balance,
            playerNumbers,
            ticketsToRedeem,
            gameTickets,
            isFirstTicket,
            ticketQuantity,
            affiliate,
            externalAid,
            walletUpdateAvailable,
            etokenTimeout,
            checkTicketRedeemability, 
            redeemTicket,
            changeEmail,
            importWallet,
            validateMnemonic,
            updateWallet,
            getFormattedTicketData,
            setUser,
            setEmail,
            setTicketQuantity,
            setProtection,
            setLoadingStatus,
            setPlayerNumbers,
            setTicketsToRedeem,
            setGameTickets,
            setEtokenTimeout,
        }}>
            {children}
            {loadingStatus && <Loading>{loadingStatus}</Loading>}
        </AppContext.Provider>
    )
};

export const AppProvider = ({ Loading, children }) => {

    const { wallet } = useCashTab();
    const address = wallet.Path1899.cashAddress;
    const [modal, modalHolder] = Modal.useModal();

    const [user, setUser] = useState({});

    /** @type {[boolean, (value: boolean) => void]} */
    const [geoProtection, setGeoProtection] = useState(true);

    /** @type {[boolean, (value: boolean) => void]} */
    const [kycProtection, setKycProtection] = useState(true);

    /** @type {[boolean, (value: boolean) => void]} */
    const [isLoading, setIsLoading] = useState(true);

    /** @type {[boolean, (value: boolean) => void]} */
    const [checksDone, setChecksDone] = useState(false);

    // get user data
    useEffect(() => {
        const getUser = async () => {
            try {
                const accessRes = await fetch(`https://lsbx.nmrai.com/v1/access/${wallet.Path1899.publicKey}`, {
                    signal: AbortSignal.timeout(20000),
                    headers: new Headers({
                        "Content-Type": "application/json"
                    })
                });
                const accessData = await accessRes.json();

                const msg = Buffer.from(accessData.access, 'utf-8');
                const keyring = KeyRing.fromSecret(wallet.Path1899.fundingWif, null);
                const sig = keyring.sign(SHA256.digest(msg));

                const userRes = await fetch("https://lsbx.nmrai.com/v1/user/", {
                    method: "POST",
                    signal: AbortSignal.timeout(20000),
                    headers: new Headers({
                        "Content-Type": "application/json"
                    }),
                    body: JSON.stringify({
                        access: accessData.access,
                        pubkey: wallet.Path1899.publicKey,
                        signature: sig.toString('hex')
                    }),
                });
                const user = await userRes.json();

                // evaluate access based on kyc
                let accessDenied = false;
                if (user.kyc_status?.includes("declined") || user.kyc_status?.includes("error")) {
                    console.log("kyc declined")
                    accessDenied = true;
                    // nothing is allowed
                    // show  info modal
                    const modalConfig = {
                        title: "Access denied",
                        content: "Your KYC has been declined.",
                    };
                    modal.info(modalConfig);
                } else if (user.kyc_status === "needs_review") {
                    console.log("kyc needs review");
                    accessDenied = false;
                    // user has to wait until email notification
                    // show info modal
                    const modalConfig = {
                        title: "Your KYC Needs Review",
                        content: "You will receive an email when this issue is resolved.",
                    };
                    modal.info(modalConfig);
                } else {
                    console.log("kyc approved or outstanding")
                    // user is either approved or not yet kyced
                    setKycProtection(false);
                }

                // evaluate access based on ip
                if (!accessDenied) {
                    // get ip data if missing
                    if (!user.ipGeo) {
                        const geoRes = await fetch(`https://lsbx.nmrai.com/v1`, {
                            signal: AbortSignal.timeout(20000)
                        });
                        const geoData = await geoRes.json();
                        console.log("geodata", geoData);

                        user.ipGeo = geoData.ipGeo;
                    }

                    // evaluate ip access
                    if (user.ipGeo.ticketPurchase) {
                        console.log("allow ticket purchase")
                        // everything is allowed
                        setGeoProtection(false);
                    } else if (user.ipGeo.affiliate) {
                        console.log("allow affiliate")
                        // show info screen for affiliates
                        const modalConfig = {
                            title: "Access restricted",
                            content: "You can not purchase tickets, but you can be an affiliate",
                            onOk: () => {
                                setGeoProtection(false);
                            },
                        };
                        modal.info(modalConfig);
                    } else {
                        console.log("allow nothing")
                        accessDenied = true;
                        // nothing is allowed
                        // show  info modal
                        const modalConfig = {
                            title: "Access denied",
                            content: "You can not access this site from your location.",
                        };
                        modal.info(modalConfig);
                    }
                }

                // pass user data 
                setUser(user);
                setChecksDone(true);
            } catch (error) {
                console.error("Error fetching user data:", error);
            } finally {
                setIsLoading(false);
            }
        }

        getUser();
    }, [address]);

    if (isLoading) {
        return <>{modalHolder}<Loading>Loading Wallet...</Loading></>;
    }

    if (geoProtection || kycProtection || !checksDone) {
        return <>{modalHolder}<Loading>Access Denied!</Loading></>;
    }

    if (!user || Object.keys(user).length === 0) {
        return <>{modalHolder}<Loading>User Not Found!</Loading></>;
    }

    return (
        <AppWrapper user={user} setUser={setUser} Loading={Loading}>
            {children}
        </AppWrapper>
    )
}

/**
 * Custom hook to access AppContext.
 * 
 * @returns {import('./types').AppContextValue} The context object, containing wallet and associated functions.
 */
export const useApp = () => {
    const context = useContext(AppContext);
    if (!context) {
        throw new Error("useApp must be used within a AppProvider");
    }
    // @ts-ignore
    return context;
};